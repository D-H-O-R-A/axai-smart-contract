#address in testnet 3N19jxhEYkphA6vga9hXTPsU5YfRMR27YoE

{-# STDLIB_VERSION 5     #-}
{-# SCRIPT_TYPE ACCOUNT  #-}
{-# CONTENT_TYPE DAPP    #-}

### keys ###

#value data account
let main = "main_asset"
let l = "lp_asset_"
let a1 = "swap_asset1_"
let st = "address_staker_"
let sst = "address_pool_"
let swp = "address_swap_"
let a2 = "swap_asset2_"
let aa1 = "pool_1_"
let aa2 = "pool_2_"
let st1 = "staker_address"
let type = "type_"
let leasePool = Address(this.bytes)
let sa = "STAKING_AMOUNT_"
let la = "LEASE_AMOUNT_"
let ix = "ID_"
let exchangeRate = 5
func getAddressIfValid(address: String) = toString(valueOrErrorMessage(addressFromString(address), "Can't parse " + address + " as address"))

#Add new main Asset
@Callable(i)
func addMainAsset(id: String) = {
    if ((i.caller == this))
      then [StringEntry(main, id)]
    else throw("Only the Admin itself can invoke this function")
}

#add new pool
@Callable(i)
func addPool(addres: String, pair: String, lp: String, stake: String, asset1: String, asset2: String) = {
    let address = getAddressIfValid(addres)
    let staker = getAddressIfValid(stake)
    let PMAA = getString(this, address)
    if((i.caller == this))
      then if(isDefined(PMAA))
        then throw("The pool has been previously added.")
        else if(addres == staker)
          then throw("Pool address cannot be the same as staker")
          else [StringEntry(address, pair), StringEntry("POOL_" + pair, staker), StringEntry(l+pair, lp),StringEntry(aa1+address,asset1),StringEntry(aa2+address,asset2), StringEntry(type+address, "pools")]
    else throw("Only the Admin itself can invoke this function")
}

#power on/off dApp
@Callable(i)
func activate(v: Boolean) = {
    if((i.caller == this))
      then [BooleanEntry("activate", v)]
    else throw("Only the Admin itself can invoke this function")
}

#add new swap
@Callable(i)
func addSwap(addres: String,stake: String, pair: String, asset1: String, asset2: String) = {
    let address = getAddressIfValid(addres)
    let staker = getAddressIfValid(stake)
    let PMAA = getString(this, address)
    if((i.caller == this))
      then if(isDefined(PMAA))
        then throw("The address for this swap has been previously added.")
        else if(addres == staker)
          then throw("Swap address cannot be the same as staker")
          else [StringEntry("swap_"+pair, staker),StringEntry(address, pair), StringEntry(a1 + address, asset1), StringEntry(a2 + address, asset2), StringEntry(type+address, "swap")]
    else throw("Only the Admin itself can invoke this function")
}

#remove swap or pool
@Callable(i)
func removeSwapOrPool(address: String) = {
  let PAA = getStringValue(this, type+address)
  let PMAA = getStringValue(this, address)
  if((i.caller == this))
    then if(PAA == "swap")
      #if  is swap
      then 
        let deletEnty = [DeleteEntry("swap_"+PMAA), DeleteEntry(address), DeleteEntry(type+address),DeleteEntry(a1+address),DeleteEntry(a2+address)]
        deletEnty
      
      #if is pool
    else {
      let bbentry = [DeleteEntry(address),DeleteEntry("POOL_" + PMAA),DeleteEntry("lp_asset_"+PMAA),DeleteEntry(aa1+address), DeleteEntry(aa2+address), DeleteEntry(type+address)]
      bbentry
    }
  else throw("Only the Admin itself can invoke this function")
}

@Verifier(tx)
func verify() = match tx {
    case _ => 
        sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
}
