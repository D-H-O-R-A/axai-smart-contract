{-# STDLIB_VERSION 5     #-}
{-# SCRIPT_TYPE ACCOUNT  #-}
{-# CONTENT_TYPE DAPP    #-}

### keys ###

#value data account
let main = "main_asset"
let l = "lp_asset_"
let aa1 = "pool__"
let sa = "STAKING_AMOUNT_"
let la = "LEASE_AMOUNT_"
let ix = "ID_"
let rateFee = "percentage_rate_fee"
let deposit_height = "Deposit_Height_Of_"

#decimals for assets
let D8 = 100000000
let D6 = 1000000

#smart contract address
let contractAddress = Address(this.bytes)

#standard exchange rate
let exchangeRate = 5

#address is valid
func getAddressIfValid(address: String) = toString(valueOrErrorMessage(addressFromString(address), "Can't parse " + address + " as address"))

#assetId is valid
func getAssetIfValid(assetId: String) = toBase58String(valueOrErrorMessage(assetInfo(fromBase58String(assetId)).value().id, "Asset Id: " + assetId +  " is invalid."))

#get total amount block in smart contract for asset
func getAmountBlockAsset(assetId:String) = valueOrElse(getIntegerValue(this, assetId),0)

#config
let ac = "activate"
let poolAc = "activate_pools"
let swapAc = "activate_swap"
let liquidityAc = "activate_liquidity"
let bcD = "block_distribuition"
# let typeBcd = "type_block_distribution"
let total_locked = "Total_Tokens_Locked_"

#assets
let usdn = "usdn_asset"
let usdt = "usdt_asset"
let usdc = "usdc_asset"
let ngnn = "ngnn_asset"
let aWaves = "accept_waves"

#key for pools
func kp(asset1: String, asset2: String) = (aa1 + asset1 + "_" + asset2)

#returns if pool is valid
func validPoolK(key:String) = valueOrElse(getInteger(this, key),0)

#returns value that the account has in the pool
func kpAddress(address:String, key:String) = valueOrElse(getIntegerValue(this,key + "_" + address),0)

#returns value that the account has in the pool for asset block
func poolAA(address:String, key:String, asset: String) = valueOrElse(getIntegerValue(this, key + "_" + address + "_" + asset), 1)

#return total asset for pool in smart contract
func assetP(key:String, asset: String) = valueOrElse(getIntegerValue(this,key+"_"+asset),1) 

#return height for pool address key
func pkey(Asset1: String,Asset2: String, address: String) = (deposit_height + kp(Asset1, Asset2) + "_" + address)

#return the value for asset lp blocked in stake
func lpBlocked(address: String, key: String) = valueOrElse(getIntegerValue(this, "STAKE_LP_" +address + "_"+key), 0)

#admin verification
func adminVerification() = match (getStringValue(this, "admin")) {
    case t: String => Address(fromBase58String(t))
    case _ => this
} 

#### Constructor for start smart contract ####
@Callable(i)
# func constructor(MainAssetId: String, UsdnAssetId: String, UsdtAssetId:String, UsdcAssetId: String, NgnnAssetId: String, acceptWaves: Boolean, percentageRateSwap: Int, blockDistribution: Int) = {
func constructor(MainAssetId: String, UsdnAssetId: String, UsdtAssetId:String, UsdcAssetId: String, NgnnAssetId: String, percentageRateSwap: Int, blockDistribution: Int) = {
    if ((i.caller == this || i.caller == adminVerification()))
      then {
        #usdn - all assets
        let keyPoolUsdnUsdt = kp(UsdnAssetId, UsdtAssetId)
        let keyPoolUsdnUsdc = kp(UsdnAssetId, UsdcAssetId)
        let keyPoolUsdnNgnn = kp(UsdnAssetId, NgnnAssetId)
        let keyPoolUsdnWaves = kp(UsdnAssetId, "WAVES")
        let keyPoolUsdnMainAsset = kp(UsdnAssetId, MainAssetId)

        #usdc - all assets
        let keyPoolUsdcUsdt = kp(UsdcAssetId, UsdtAssetId)
        let keyPoolUsdcNgnn = kp(UsdcAssetId, NgnnAssetId)
        let keyPoolUsdcWaves = kp(UsdcAssetId, "WAVES")
        let keyPoolUsdcMainAsset = kp(UsdcAssetId, MainAssetId)

        #usdt - all assets
        let keyPoolUsdtNgnn = kp(UsdtAssetId, NgnnAssetId)
        let keyPoolUsdtWaves = kp(UsdtAssetId, "WAVES")
        let keyPoolUsdtMainAsset = kp(UsdtAssetId, MainAssetId)

        #ngnn - all assets
        let keyPoolNgnnWaves = kp(NgnnAssetId, "WAVES")
        let keyPoolNgnnMainAsset = kp(NgnnAssetId, MainAssetId)

        #main asset - all assets
        let keyPoolMainWaves = kp(MainAssetId, "WAVES")
      [
      StringEntry(main, MainAssetId), 
      StringEntry(usdn, UsdnAssetId), 
      StringEntry(usdc, UsdcAssetId), 
      StringEntry(usdt, UsdtAssetId), 
      StringEntry(ngnn, NgnnAssetId), 
      # BooleanEntry(aWaves, acceptWaves), 
      IntegerEntry(rateFee, percentageRateSwap),
      BooleanEntry(ac, true), 
      BooleanEntry(swapAc, false), 
      BooleanEntry(poolAc, false), 
      BooleanEntry(liquidityAc, false), 
      IntegerEntry(bcD, blockDistribution),
      IntegerEntry(keyPoolUsdnUsdt, 1),
      IntegerEntry(keyPoolUsdnWaves, 1),
      IntegerEntry(keyPoolUsdnUsdc, 1),
      IntegerEntry(keyPoolUsdnNgnn, 1),
      IntegerEntry(keyPoolUsdnMainAsset, 1),
      IntegerEntry(keyPoolUsdcUsdt,1),
      IntegerEntry(keyPoolUsdcNgnn,1),
      IntegerEntry(keyPoolUsdcWaves,1),
      IntegerEntry(keyPoolUsdtMainAsset,1),
      IntegerEntry(keyPoolUsdtNgnn,1),
      IntegerEntry(keyPoolUsdtWaves,1),
      IntegerEntry(keyPoolNgnnWaves,1),
      IntegerEntry(keyPoolNgnnMainAsset,1),
      IntegerEntry(keyPoolMainWaves,1)
      ]
      }
    else throw("Only the Admin itself can invoke this function")
}

#### Admin settings and options ####

#power on/off dApp
@Callable(i)
func activate(v: Boolean) = {
    if((i.caller == this || i.caller == adminVerification()))
      then [BooleanEntry(ac, v)]
    else throw("Only the Admin itself can invoke this function")
}

#activate and desactivate pools/swap/liquidity
@Callable(i)
func maintenance(pools: Boolean, swap: Boolean, stake: Boolean) = {
  if((i.caller == this || i.caller == adminVerification()))
   then [BooleanEntry(poolAc, pools), BooleanEntry(swapAc, swap), BooleanEntry(liquidityAc, stake)]
  else throw("Only the Admin itself can invoke this function")
}

#edit percentual rate for fees swap
@Callable(i)
func percentualRateFeeSwapEdit(rate: Int) = {
  if((i.caller == this || i.caller == adminVerification()))
   then [IntegerEntry(rateFee, rate)]
  else throw("Only the Admin itself can invoke this function")
}

#edit accept Waves
# @Callable(i)
# func acceptWaves(activate: Boolean) = {
#   if((i.caller == this || i.caller == adminVerification()))
#    then [BooleanEntry(aWaves, activate)]
#   else throw("Only the Admin itself can invoke this function")
# }

#edit block distribution
@Callable(i)
func blockDistribution(newValue: Int) = {
  if((i.caller == this || i.caller == adminVerification()))
   then [IntegerEntry(bcD, newValue)]
  else throw("Only the Admin itself can invoke this function")
}

#add admin for smart contract
@Callable(i)
func addAdmin(address: String) = {
  if((i.caller == this || i.caller == adminVerification()))
   then{
     [
      StringEntry("admin", address)
     ]
   }
  else throw("Only the Admin itself can invoke this function")
}

#create lp asset for initial config
@Callable(i)
func lpAssetCreateForPairPool(asset1: String, asset2: String, name: String) = {
  let key = validPoolK(kp(asset1, asset2))
  if((i.caller == this || i.caller == adminVerification()))
   then if(!(key == 0))
    then {
      let assetLpCreate = Issue("LP_" + name, "LP asset for pool liquidity in AxAi Swap pair " + asset1 + "_"+ asset2, 1,8,true)
      let idAssetLp = calculateAssetId(assetLpCreate)
      [
       StringEntry(l+kp(asset1, asset2), toBase58String(idAssetLp))
      ]
    }
    else throw("Invalid Pool Key. Try inverting the assets")
  else throw("Only the Admin itself can invoke this function")
}


### add and remove stake ###

#stake main asset and lp assets valid in smart contract
@Callable(i)
func deposit(pool: Boolean, Asset1: String, Asset2: String) = {
  #main validations
  let power = getBooleanValue(this, ac)
  let liquidityPower = getBooleanValue(this, liquidityAc)
  # let acWaves = getBooleanValue(this, aWaves)

  #payment 
  # let USDN = toBytes(getStringValue(this, usdn))
  # let USDC = toBytes(getStringValue(this, usdc))
  # let USDT = toBytes(getStringValue(this, usdt))
  # let NGNN = toBytes(getStringValue(this, ngnn))
  let MainAsset = (getStringValue(this, main))
  let lpAssetId = if(pool) then (getStringValue(this,l+kp(Asset1, Asset2))) else MainAsset #get LP assetId configured for pool in smart contract by admin

  #validation and more
  if((power))
   then if(!(liquidityPower))
    then if((i.payments[0].assetId != fromBase58String(lpAssetId)))
     then throw("Invalid asset! Kindly Deposit Only " + MainAsset + " or valid asset lp")
     else{
      if(!(pool))
       then {
         let currentKey = toBase58String(i.caller.bytes)
         let currentAmount = match getInteger(this, currentKey) { 
          case a: Int => a 
          case _ => 0 
         }
         let newAmount = (currentAmount + i.payments[0].amount)
         let useramount = IntegerEntry(currentKey, newAmount)
         let userdepositheight = IntegerEntry((deposit_height+ currentKey), height)
         let previouslockbalance = match getInteger(this, "Total_Tokens_Locked:"){
          case a: Int => a
          case _ => 0 
         }
         let totaltoken = (previouslockbalance + i.payments[0].amount)
         let TLV = IntegerEntry("Total_Tokens_Locked:", totaltoken)
         [useramount, userdepositheight, TLV]
       }
       else{
         let poolKey = kp(Asset1, Asset2)
         let key = validPoolK(poolKey)
         if(!(key == 0))
          then{
            let currentKey = toBase58String(i.caller.bytes)
            let currentAmount = match getInteger(this, "STAKE_LP_" +currentKey + "_"+poolKey) {
              case a: Int => a
              case _ => 0
            }
            let newAmount = (currentAmount + i.payments[0].amount)
            let useramount = IntegerEntry("STAKE_LP_" +currentKey + "_"+poolKey, newAmount)
            let userdepositheight = IntegerEntry((deposit_height+ "_"+ currentKey + "_"+poolKey), height)
            let previouslockbalance = match getInteger(this, "Total_Tokens_LP_Locked_" + poolKey){ 
              case a:Int => a
              case _ => 0
            }
            let totaltoken = (previouslockbalance + i.payments[0].amount)
            let TLV = IntegerEntry("Total_Tokens_LP_Locked_" + poolKey, totaltoken)
            [useramount, userdepositheight, TLV]
          }
          else throw("Invalid Pool key.")
       }
    }
   else throw("liquidity is currently under maintenance.")
  else throw("dApp is currently under maintenance.")
}

#remove stake for main asset and lp assets valid in smart contract
@Callable(i)
func remove(pool: Boolean, Asset1: String, Asset2: String,amount: Int) = {
  #main validations
  let power = getBooleanValue(this, ac)
  let liquidityPower = getBooleanValue(this, liquidityAc)
  # let acWaves = getBooleanValue(this, aWaves)

  #payment 
  let pmt =i.payments[0]
  # let USDN = toBytes(getStringValue(this, usdn))
  # let USDC = toBytes(getStringValue(this, usdc))
  # let USDT = toBytes(getStringValue(this, usdt))
  # let NGNN = toBytes(getStringValue(this, ngnn))
  let MainAsset = fromBase58String(getStringValue(this, main))

  #validation and more
  if((power))
   then if(!(liquidityPower)) 
    then{
    let currentKey = toBase58String(i.caller.bytes)
    let currentAmount = valueOrElse(if(pool) then getIntegerValue(this,"STAKE_LP_" +currentKey + "_"+kp(Asset1, Asset2)) else getInteger(this, currentKey), 0)
    let swapheightkeyname = if(pool) then (deposit_height+ "_"+ currentKey + "_"+kp(Asset1, Asset2)) else(deposit_height + currentKey)
    let previouslockbalance = if(pool) then getIntegerValue(this, "Total_Tokens_LP_Locked_" +kp(Asset1, Asset2)) else getIntegerValue(this, "Total_Tokens_Locked:")
    let totaltoken = (previouslockbalance - amount)
    let diff = (height - getIntegerValue(this, swapheightkeyname))
    let bcd = getIntegerValue(this, bcD)
    let reward = (diff * bcd) * D8
    let feeCalc = reward / (previouslockbalance/amount)
    if ((0 > amount))
      then throw(if(pool) then "Can't withdraw negative "+ Asset1 + "/" + Asset2 +  " amount" else "Can't withdraw negative AxAi amount")
      else {
       let newAmount = (currentAmount - amount)
       if ((0 > newAmount))
        then throw(if(pool) then "Not enough Asset Lp " + Asset1 + "/" + Asset2 +  " balance" else "Not enough AxAi balance")
          else [
            IntegerEntry(if(pool) then "STAKE_LP_" +currentKey + "_"+kp(Asset1, Asset2) else currentKey, newAmount), 
            IntegerEntry(if(pool) then "Total_Tokens_LP_Locked_" +kp(Asset1, Asset2) else "Total_Tokens_Locked:", totaltoken),
            ScriptTransfer(i.caller, amount, if(pool) then fromBase58String(getStringValue(this,l+kp(Asset1, Asset2))) else MainAsset), 
            ScriptTransfer(i.caller,feeCalc, MainAsset)
          ]
      }
    }
   else throw("liquidity is currently under maintenance.")
  else throw("dApp is currently under maintenance.")
}

#### pools - add and remove liquidity ####

#add liquidity
@Callable(i)
func addLiquidity(Asset1:String, Asset2: String) = {
  #main validations
  let power = getBooleanValue(this, ac) #checks if the smart contract is activate
  let poolActivate = getBooleanValue(this, poolAc) #check if the pool in the smart contract is activate
  # let acWaves = getBooleanValue(this, aWaves) #check if the smart contract accept payment using Waves
  let key = validPoolK(kp(Asset1, Asset2)) #get pool key (if existing) in smart contract for validation

  #payment 
  let asset1 = i.payments[0].assetId #get asset1 used for payment 
  let asset2 = i.payments[1].assetId #get asset2 used for payment
  let USDN = toBytes(getStringValue(this, usdn)) #get USDN assetId configured in smart contract
  let USDC = toBytes(getStringValue(this, usdc)) #get USDC assetId configured in smart contract
  let USDT = toBytes(getStringValue(this, usdt)) #get USDT assetId configured in smart contract
  let NGNN = toBytes(getStringValue(this, ngnn)) #get NGNN assetId configured in smart contract
  let MainAsset = fromBase58String(getStringValue(this, main)) #get Main assetId configured in smart contract
  let lpAssetId = getStringValue(this,l+kp(Asset1, Asset2)) #get LP assetId configured for pool in smart contract by admin

  #validation and more
  if((power)) #if the smart contract is activate
   then if(!(poolActivate)) #if pool is activate
    then if(!(asset1 == asset2) && (asset1 == fromBase58String(Asset1)) && (asset2 == fromBase58String(Asset2))) #if asset1 and asset2 they're not the equal and asset payment and asset string is equal
     then if((asset1 == USDN || asset1 == USDC || asset1 == USDT || asset1 == NGNN || asset1 == MainAsset) && (asset2 == USDN || asset2 == USDC || asset2 == USDT || asset2 == NGNN || asset2 == MainAsset)) #check if the asset1 and asset2 is valid with assets configured in the smart contract
      then if(!(key == 0)) #if pool key is valid 
       then{
        #get old or new values for account
        let currentKey = toBase58String(i.caller.bytes) #get address for user
        let currentAmount = kpAddress(currentKey,kp(Asset1, Asset2)) #get amount LP locked by address
        let currentAmountAsset1 = poolAA(currentKey, kp(Asset1, Asset2), Asset1) #get amount locked by address for the asset1 if the lp token is not locked
        let currentAmountAsset2 = poolAA(currentKey, kp(Asset1, Asset2), Asset2) #get amount locked by address for the asset2 if the lp token is not locked
        let asset1pool = assetP(kp(Asset1, Asset2), Asset1) #get the total amount locked in smart contract for asset1
        let asset2pool = assetP(kp(Asset1, Asset2), Asset2) #get the total amount locked in smart contract for asset2
        let receiveLp = asset1pool/asset2pool #get total asset lp which should be passed on based on the total pooled value of both assets
        #new values based on old values
        let newcurrentAmountAsset1 = currentAmountAsset1 + i.payments[0].amount #updates the total of values ​​blocked by the address in the pool for asset1
        let newcurrentAmountAsset2 = currentAmountAsset2 + i.payments[1].amount #updates the total of values ​​blocked by the address in the pool for asset2
        let newcurrentAmount = currentAmount + receiveLp #updates the total of values ​​blocked by the address in the pool for lp asset
        let newasset1pool = asset1pool + i.payments[0].amount #updates the total of values ​​blocked in the pool for asset1
        let newasset2pool = asset2pool + i.payments[1].amount #updates the total of values ​​blocked in the pool for asset2
        [
         Reissue(fromBase58String(lpAssetId), receiveLp,true),
         ScriptTransfer(Address(i.caller.bytes),receiveLp,fromBase58String(lpAssetId)), #transfer lp asset for address
         IntegerEntry(pkey(Asset1, Asset2, currentKey), height), #updates the lock height of values ​​in the pool
         IntegerEntry(currentKey + "_" + kp(Asset1, Asset2) + "_" + Asset1, newcurrentAmountAsset1), #update the amount loked by address for the asset1 in pool
         IntegerEntry(currentKey + "_" + kp(Asset1, Asset2) + "_" + Asset2, newcurrentAmountAsset2), #update the amount loked by address for the asset2 in pool
         IntegerEntry(kp(Asset1, Asset2) + "_" + currentKey,newcurrentAmount), #updates the total of values ​​blocked by the address in the pool for lp asset
         IntegerEntry(kp(Asset1, Asset2)+"_"+Asset1, newasset1pool), #update the total amount of values blocked in pool for asset1
         IntegerEntry(kp(Asset1, Asset2)+"_"+Asset2, newasset2pool), #update the total amount of values blocked in pool for asset2
         IntegerEntry(Asset1, getAmountBlockAsset(Asset1) + i.payments[0].amount), #update the total amount of values blocked in smart contract for asset1
         IntegerEntry(Asset2, getAmountBlockAsset(Asset2) + i.payments[1].amount), #update the total amount of values blocked in smart contract for asset2
         IntegerEntry(lpAssetId, getAmountBlockAsset(lpAssetId) + receiveLp) #update the total amount of values blocked in pool for asset lp
        ]
       }
      else throw("Invalid Pool Key.")
     else throw("Invalid Asset1 or Asset2!")
    else throw("Asset1 cannot be equal to Asset2")
   else throw("liquidity is currently under maintenance.")
  else throw("dApp is currently under maintenance.")
}

#remove liquidity
@Callable(i)
func removeLiquidity(Asset1: String, Asset2: String, Amount: Int) = {
  let currentKey = toBase58String(i.caller.bytes) #get address for user
  #main validations
  let power = getBooleanValue(this, ac) #checks if the smart contract is activate
  let poolActivate = getBooleanValue(this, poolAc) #check if the pool in the smart contract is activate
  # let acWaves = getBooleanValue(this, aWaves) #check if the smart contract accept payment using Waves
  let poolKey = kp(Asset1, Asset2)
  let key = validPoolK(poolKey) #get pool key (if existing) in smart contract for validation

  let asset1 = fromBase58String(Asset1)
  let asset2 = fromBase58String(Asset2)
  let USDN = toBytes(getStringValue(this, usdn)) #get USDN assetId configured in smart contract
  let USDC = toBytes(getStringValue(this, usdc)) #get USDC assetId configured in smart contract
  let USDT = toBytes(getStringValue(this, usdt)) #get USDT assetId configured in smart contract
  let NGNN = toBytes(getStringValue(this, ngnn)) #get NGNN assetId configured in smart contract
  let MainAsset = fromBase58String(getStringValue(this, main)) #get Main assetId configured in smart contract
  let lpAssetId = getStringValue(this,l+kp(Asset1, Asset2)) #get LP assetId configured for pool in smart contract by admin
  let currentAmount = kpAddress(currentKey,kp(Asset1, Asset2)) #get amount LP locked by address
  let amountLpBlocked = lpBlocked(currentKey,poolKey)
  let totalLP = getIntegerValue(this, lpAssetId)
  let totalAsset1Pool = getIntegerValue(this, kp(Asset1, Asset2)+"_"+Asset1)
  let totalAsset2Pool = getIntegerValue(this, kp(Asset1, Asset2)+"_"+Asset2)

  #validation and more
  if((power)) #if the smart contract is activate
   then if(!(poolActivate)) #if pool is activate
    then if(!(Asset1 == Asset2)) #if asset1 and asset2 they're not the equal and asset payment and asset string is equal
     then if((asset1 == USDN || asset1 == USDC || asset1 == USDT || asset1 == NGNN || asset1 == MainAsset) && (asset2 == USDN || asset2 == USDC || asset2 == USDT || asset2 == NGNN || asset2 == MainAsset)) #check if the asset1 and asset2 is valid with assets configured in the smart contract
      then if(!(key == 0)) #if pool key is valid 
       then if(!(currentAmount == 0))
        then if((currentAmount-amountLpBlocked) >= Amount)
          then{
            let calcLP = Amount/totalLP
            let receiveAsset1 = calcLP*totalAsset1Pool
            let receiveAsset2 = calcLP*totalAsset2Pool
            let asset1pool = assetP(kp(Asset1, Asset2), Asset1) #get the total amount locked in smart contract for asset1
            let asset2pool = assetP(kp(Asset1, Asset2), Asset2) #get the total amount locked in smart contract for asset2
            let currentAmountAsset1 = poolAA(currentKey, kp(Asset1, Asset2), Asset1) #get amount locked by address for the asset1 if the lp token is not locked
            let currentAmountAsset2 = poolAA(currentKey, kp(Asset1, Asset2), Asset2) #get amount locked by address for the asset2 if the lp token is not locked
            let newcurrentAmountAsset1 = currentAmountAsset1 - receiveAsset1 #updates the total of values ​​blocked by the address in the pool for asset1
            let newcurrentAmountAsset2 = currentAmountAsset2 - receiveAsset2 #updates the total of values ​​blocked by the address in the pool for asset2
            let newcurrentAmount = currentAmount - Amount #updates the total of values ​​blocked by the address in the pool for lp asset
            let newasset1pool = asset1pool - receiveAsset1 #updates the total of values ​​blocked in the pool for asset1
            let newasset2pool = asset2pool - receiveAsset2 #updates the total of values ​​blocked in the pool for asset2
            [
             Burn(fromBase58String(lpAssetId), Amount),
             ScriptTransfer(Address(i.caller.bytes),receiveAsset1,asset1),
             ScriptTransfer(Address(i.caller.bytes),receiveAsset2,asset2),
             IntegerEntry(pkey(Asset1, Asset2, currentKey), height), #updates the lock height of values ​​in the pool
             IntegerEntry(currentKey + "_" + kp(Asset1, Asset2) + "_" + Asset1, newcurrentAmountAsset1), #update the amount loked by address for the asset1 in pool
             IntegerEntry(currentKey + "_" + kp(Asset1, Asset2) + "_" + Asset2, newcurrentAmountAsset2), #update the amount loked by address for the asset2 in pool
             IntegerEntry(kp(Asset1, Asset2) + "_" + currentKey,newcurrentAmount), #updates the total of values ​​blocked by the address in the pool for lp asset
             IntegerEntry(kp(Asset1, Asset2)+"_"+Asset1, newasset1pool), #update the total amount of values blocked in pool for asset1
             IntegerEntry(kp(Asset1, Asset2)+"_"+Asset2, newasset2pool), #update the total amount of values blocked in pool for asset2
             IntegerEntry(Asset1, getAmountBlockAsset(Asset1) - receiveAsset1), #update the total amount of values blocked in smart contract for asset1
             IntegerEntry(Asset2, getAmountBlockAsset(Asset2) - receiveAsset2), #update the total amount of values blocked in smart contract for asset2
             IntegerEntry(lpAssetId, getAmountBlockAsset(lpAssetId) - Amount) #update the total amount of values blocked in pool for asset lp
            ]
          }
        else throw("Amount to be withdrawn greater than the amount available for withdrawal.")
       else throw("You have no locked values ​​in the pool")
      else throw("Invalid Pool Key.")
     else throw("Invalid Asset1 or Asset2!")
    else throw("Asset1 cannot be equal to Asset2")
   else throw("liquidity is currently under maintenance.")
  else throw("dApp is currently under maintenance.")
}

### swap for pairs valid ###

#swap function
@Callable(i)
func swap(Asset1: String, Asset2: String) = {
  let currentKey = toBase58String(i.caller.bytes) #get address for user
  #main validations
  let power = getBooleanValue(this, ac) #checks if the smart contract is activate
  let swapActivate = getBooleanValue(this, swapAc) #check if the swap is activate
  let poolKey = kp(Asset1, Asset2)
  let key = validPoolK(poolKey) #get pool key (if existing) in smart contract for validation
  
  #payment 
  let asset1 = i.payments[0].assetId #get asset1 used for payment 
  let USDN = toBytes(getStringValue(this, usdn)) #get USDN assetId configured in smart contract
  let USDC = toBytes(getStringValue(this, usdc)) #get USDC assetId configured in smart contract
  let USDT = toBytes(getStringValue(this, usdt)) #get USDT assetId configured in smart contract
  let NGNN = toBytes(getStringValue(this, ngnn)) #get NGNN assetId configured in smart contract
  let MainAsset = fromBase58String(getStringValue(this, main)) #get Main assetId configured in smart contract

  #value for pool
  let totalAsset1 = getIntegerValue(this,kp(Asset1, Asset2)+"_"+Asset1)
  let totalAsset2 = getIntegerValue(this, kp(Asset1, Asset2)+"_"+Asset2)
  let feeRatePercentual = getIntegerValue(this, rateFee)

  if(power)
   then if(!(swapActivate))
    then if(!(Asset1 == Asset2) && (asset1 == fromBase58String(Asset1) || asset1  == fromBase58String(Asset2))) #if asset1 and asset2 they're not the equal and asset payment and asset string is equal
     then if((asset1 == USDN || asset1 == USDC || asset1 == USDT || asset1 == NGNN || asset1 == MainAsset)) #check if the asset1 and asset2 is valid with assets configured in the smart contract
      then if(!(key == 0)) #if pool key is valid
       then if(i.payments[1].assetId == MainAsset)
         then if(i.payments[1].amount == 300000)
          then{
            let valueAsset = if(!(asset1 == fromBase58String(Asset1))) then totalAsset1/totalAsset2 else totalAsset2/totalAsset1
            let newValue = i.payments[0].amount - (i.payments[0].amount * feeRatePercentual) / (100* D8)
            let sendValue = newValue * valueAsset
            [
               ScriptTransfer(Address(i.caller.bytes), sendValue, fromBase58String(Asset2)),
               IntegerEntry(Asset2, getAmountBlockAsset(Asset2) - sendValue),
               IntegerEntry(kp(Asset1, Asset2)+"_"+Asset2,assetP(kp(Asset1, Asset2), Asset2)-sendValue)
            ]
          }
        else throw("Swap denied! 0.003 AxAi is required for the swap fee.")
       else throw("Invalid rate asset")
      else throw("Invalid Swap Key.")
     else throw("Invalid Asset1 or Asset2!")
    else throw("Asset1 cannot be equal to Asset2")
   else throw("Swap is currently under maintenance.")
  else throw("dApp is currently under maintenance.")
}

#validate transaction in smart contract
@Verifier(tx)
func verify() = match (tx) {
    case order: Order => if(order.orderType == Buy) then if(order.assetPair.amountAsset == fromBase58String(getStringValue(this,main)) && (order.assetPair.priceAsset == fromBase58String(getStringValue(this,usdn)) || order.assetPair.priceAsset == unit)) then sigVerify(order.bodyBytes, order.proofs[0], order.senderPublicKey) else false else if(order.assetPair.amountAsset == fromBase58String(getStringValue(this,main)) && (order.assetPair.priceAsset == fromBase58String(getStringValue(this,usdn)) || order.assetPair.priceAsset == unit)) then sigVerify(order.bodyBytes, order.proofs[0], order.senderPublicKey) else false
    case e: ExchangeTransaction => if(e.buyOrder.orderType == Buy) then if(e.buyOrder.assetPair.amountAsset == fromBase58String(getStringValue(this,main)) && (e.buyOrder.assetPair.priceAsset == fromBase58String(getStringValue(this,usdn)) || e.buyOrder.assetPair.priceAsset == unit)) then sigVerify(e.bodyBytes, e.proofs[0], e.senderPublicKey) else false else if(e.sellOrder.assetPair.amountAsset == fromBase58String(getStringValue(this,main)) && (e.sellOrder.assetPair.priceAsset == fromBase58String(getStringValue(this,usdn)) || e.sellOrder.assetPair.priceAsset == unit)) then sigVerify(e.bodyBytes, e.proofs[0], e.senderPublicKey) else false
    # case tt: TransferTransaction => tt.recipient == Address(fromBase58String(getStringValue(this, "admin")))
    case _ => 
        sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
}
